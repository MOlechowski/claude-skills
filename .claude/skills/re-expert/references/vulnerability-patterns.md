# Vulnerability Patterns

Common vulnerability patterns to identify during reverse engineering.

## Stack Buffer Overflow

### Pattern
```c
char buf[64];
gets(buf);           // No bounds check
strcpy(buf, input);  // No bounds check
scanf("%s", buf);    // No width limit
```

### Identification
- Fixed-size stack buffer (sub rsp, N)
- Unbounded input function
- No stack canary check

### In Disassembly
```asm
sub    rsp, 0x50          ; Allocate buffer
lea    rdi, [rsp]         ; Buffer address
call   gets               ; Dangerous!
```

### Exploitation
- Overwrite return address
- ROP chain if NX enabled
- Ret2libc if ASLR

## Heap Overflow

### Pattern
```c
char *buf = malloc(size);
read(fd, buf, larger_size);  // Reads more than allocated
```

### Identification
- malloc/new allocation
- Write operation exceeds allocated size
- No size validation

### Targets
- Adjacent heap chunks (metadata corruption)
- Function pointers in heap objects
- vtable pointers (C++)

## Format String

### Pattern
```c
printf(user_input);      // User controls format
fprintf(fp, user_input); // User controls format
```

### Identification
- printf family with single argument
- Argument comes from user input
- No format specifier

### Exploitation
- `%x` - Leak stack values
- `%s` - Leak memory at address
- `%n` - Write to memory
- `%p` - Leak pointers (ASLR bypass)

## Use-After-Free

### Pattern
```c
free(obj);
// ... later ...
obj->method();  // Dangling pointer
```

### Identification
- Free then reference pattern
- Object reuse after destruction
- Callback after object freed

### In Code
- Look for free() calls
- Track pointer usage after free
- Check for reassignment

## Integer Overflow

### Pattern
```c
size_t size = user_width * user_height;  // Can overflow
char *buf = malloc(size);                // Small allocation
memcpy(buf, data, user_width * user_height);  // Large copy
```

### Identification
- Arithmetic before allocation
- No overflow check
- Multiplication of user values

### Dangerous Operations
```c
a + b     // Overflow
a * b     // Overflow
a - b     // Underflow (if unsigned)
(int)a    // Truncation
```

## Command Injection

### Pattern
```c
sprintf(cmd, "ls %s", user_input);
system(cmd);  // Executes user input
```

### Identification
- system(), popen(), exec*()
- User input in command string
- No sanitization

### Bypass Characters
```
; | & $ ` \n
$(cmd) `cmd`
```

## Path Traversal

### Pattern
```c
sprintf(path, "/var/www/%s", filename);
open(path, O_RDONLY);
```

### Identification
- User input in file path
- No path canonicalization
- No chroot/sandbox

### Bypass Strings
```
../../../etc/passwd
....//....//etc/passwd
%2e%2e%2f (URL encoded)
```

## Race Condition (TOCTOU)

### Pattern
```c
if (access(file, W_OK) == 0) {  // Check
    fd = open(file, O_WRONLY);   // Use (race window)
}
```

### Identification
- Check-then-use pattern
- File operations
- Symlink possible between check and use

## Dangerous Functions Reference

| Function | Risk | Safer Alternative |
|----------|------|-------------------|
| gets() | Always overflow | fgets() |
| strcpy() | Overflow | strncpy(), strlcpy() |
| strcat() | Overflow | strncat(), strlcat() |
| sprintf() | Overflow | snprintf() |
| scanf("%s") | Overflow | scanf("%Ns") with limit |
| vsprintf() | Overflow | vsnprintf() |
| realpath() | Overflow (old) | Use with PATH_MAX |
| getwd() | Overflow | getcwd() |

## Security Feature Bypass

### Stack Canary Bypass
- Information leak to get canary value
- Overwrite only specific variables (not canary)
- Fork-based brute force

### ASLR Bypass
- Information leak (format string, partial overwrite)
- Brute force (32-bit)
- Return-to-plt (known addresses)

### NX Bypass
- Return-oriented programming (ROP)
- Return-to-libc
- JIT spraying (if applicable)

### RELRO Bypass
- Partial RELRO: Overwrite GOT
- Full RELRO: Target other writable memory
